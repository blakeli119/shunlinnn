# BFS、DFS
## 流程圖
![](/image/S__82370562.jpg)
## 學習歷程
#### 利用Queue執行先進先出
![](/image/螢幕截圖%202019-12-20%2010.50.57.png)
#### 一開始在訂pop範圍時，沒有設定好而超出範圍，因此他沒辦法定義他的範圍。
![](/image/螢幕截圖%202019-12-20%2010.42.01.png)
#### 概念相似，只是是運用stack執行先進後出
![](/image/螢幕截圖%202019-12-20%2010.51.10.png)
#### 測值結果
![](/image/螢幕截圖%202019-12-20%2010.52.11.png)
## BFS和DFS的原理與比較
### BFS（廣度優先搜尋演算法）
#### 使用佇列Queue實現圖的BFS遍歷，都是照順序擺的。將已發現的頂點和未發現的之間的邊界，沿著廣度方向向外擴充套件。演算法首先會發現和s距離為k的所有頂點，然後才會發現和s距離為k+1的其他頂點。與DFS相反，BFS每次選擇深度最淺的節點優先擴充套件。並且當問題有解時，寬度優先演算法一定能夠找到解，並且在單位耗散時間的情況下，可以保證找到最優解。
### DFS（深度優先搜尋演算法）
#### 使用棧Stack迭代實現圖的DFS遍歷還有利用遞迴方式實現，照順序但只擺最上層（最後那個數）。和BFS不同的是BFS搜尋產生的始終是一棵樹，而DFS產生的可能會使一個森林。一般情況下，當問題有解時，DFS不能夠保證找到最優解，也不能保證找到解。如果問題狀態空間有限，則可以保證找到解；但是當問題的狀態空間無限時，則可能陷入深淵而找不到解。為此我們可以利用回溯演算法中的思想，可以加上對搜尋的深度限制。從而實現對於搜尋深度的限制。當然深度限制設定必須合理，深度過深則影響搜尋的效率，深度過淺時，則可能影響找到問題的解。
## 參考資料
#### https://alrightchiu.github.io/SecondRound/flow-networksmaximum-flow-ford-fulkerson-algorithm.html
#### https://www.coursehero.com/file/40393550/bfspy/
#### https://kopu.chat/2017/09/22/實作graph與dfs、bfs走訪/
#### https://blog.csdn.net/u011437229/article/details/53188837
#### https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/
